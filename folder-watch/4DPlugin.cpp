/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Folder Watch
 #	author : miyako
 #	2015/06/16
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#define CALLBACK_IN_NEW_PROCESS 0
#define CALLBACK_SLEEP_TIME 59

std::mutex globalMutex; /* WATCH_PATHS,CALLBACK_EVENT_PATHS,WATCH_PATHS_POSIX,CALLBACK_EVENT_IDS,CALLBACK_EVENT_FLAGS,MONITOR_LATENCY */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for WATCH_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

#if VERSIONMAC
@interface Listener : NSObject

{
	FSEventStreamRef stream;
}

- (void)clear;
- (void)setPaths:(NSArray *)urls latency:(NSTimeInterval)latency;

@end

@implementation Listener

- (id)init
{
	if(!(self = [super init])) return self;
	
	/* setup object instance here */
	
	stream = 0;
	
	return self;
}

- (void)dealloc
{
	[self clear];
	
	[super dealloc];
}

- (void)clear
{
	if(stream)
	{
		FSEventStreamStop(stream);
		FSEventStreamUnscheduleFromRunLoop (stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
		FSEventStreamInvalidate(stream);
		FSEventStreamRelease(stream);
		stream = 0;
	}
}

- (void)setPaths:(NSArray *)urls latency:(NSTimeInterval)latency
{
	[self clear];
	
#ifndef kFSEventStreamCreateFlagFileEvents
#define kFSEventStreamCreateFlagFileEvents 0x00000010
#endif
	
	FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
	
	stream = FSEventStreamCreate(NULL,
															 (FSEventStreamCallback)gotEvent,
															 &context,
															 (CFArrayRef)urls,
															 kFSEventStreamEventIdSinceNow,
															 (CFAbsoluteTime)latency,
															 kFSEventStreamCreateFlagUseCFTypes
															 | kFSEventStreamCreateFlagFileEvents
															 | kFSEventStreamCreateFlagNoDefer
															 /* | kFSEventStreamCreateFlagIgnoreSelf */
															 );
	
	FSEventStreamScheduleWithRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
	FSEventStreamStart(stream);
}

@end

#endif

#if VERSIONWIN
#define NSTimeInterval double
#endif

namespace FW2
{
#if VERSIONMAC
    Listener *listener = nil;
#endif
    
    //constants
	process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0F\0O\0L\0D\0E\0R\0_\0W\0A\0T\0C\0H\0\0\0";
	process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;

    //context management
	ARRAY_TEXT WATCH_PATHS;
	std::vector<CUTF16String>CALLBACK_EVENT_PATHS;
#if VERSIONMAC
    ARRAY_TEXT WATCH_PATHS_POSIX;
#endif
	NSTimeInterval MONITOR_LATENCY;
	std::vector<NSTimeInterval>CALLBACK_EVENT_IDS;
	std::vector<int>CALLBACK_EVENT_FLAGS;
	
    //callback management
    C_TEXT WATCH_METHOD;
    process_number_t METHOD_PROCESS_ID = 0;
    bool PROCESS_SHOULD_TERMINATE;
	bool PROCESS_SHOULD_RESUME = false;
}

void generateUuid(C_TEXT &returnValue)
{
#if VERSIONMAC
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
	CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
	NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
#else
	RPC_WSTR str;
	UUID uuid;
	int len;
	wchar_t *buffer;
	if (UuidCreate(&uuid) == RPC_S_OK) {
		if (UuidToString(&uuid, &str) == RPC_S_OK) {
			len = (wcslen((const wchar_t *)str) * 2) + 2;
			buffer = (wchar_t *)malloc(len); if (buffer) {
				memset(buffer, 0x00, len);
				memcpy(buffer, str, len);
				_wcsupr((wchar_t *)buffer);
				CUTF16String uid = (const PA_Unichar *)buffer;
				returnValue.setUTF16String(&uid);
				free(buffer);
			}
			RpcStringFree(&str);
		}
	}
#endif
}

#if VERSIONMAC
void listener_start()
{
	if(!FW2::listener)
	{
		FW2::listener = [[Listener alloc]init];
	}
	
	uint32_t i, length = FW2::WATCH_PATHS_POSIX.getSize();
	NSMutableArray *paths = [[NSMutableArray alloc]initWithCapacity:length];
	
	for(i = 0; i < length; ++i){
		NSString *path = FW2::WATCH_PATHS_POSIX.copyUTF16StringAtIndex(i);
		if([path length]){
			[paths addObject:path];
		}
		[path release];
	}
	/* must do this in main process */
	[FW2::listener setPaths:paths latency:FW2::MONITOR_LATENCY];
	[paths release];
}

void listener_end()
{
	/* must do this in main process */
	[FW2::listener release];
	FW2::listener = nil;
}

void gotEvent(FSEventStreamRef stream,
							void *callbackInfo,
							size_t numEvents,
							void *eventPaths,
							const FSEventStreamEventFlags eventFlags[],
							const FSEventStreamEventId eventIds[]
							) {
	
	NSArray *paths = (NSArray *)(CFArrayRef)eventPaths;
	NSMutableString *pathsString = [[NSMutableString alloc]init];
	NSMutableArray *flags = [[NSMutableArray alloc]init];
	
	for(uint32_t i = 0; i < [paths count] ; ++i)
	{
		NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)[paths objectAtIndex:i], kCFURLPOSIXPathStyle, false);
		if(u)
		{
			NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLHFSPathStyle);
			uint32_t len = [path length];
			uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
			std::vector<uint8_t> buf(size);
			if([path getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
			{
				CUTF16String event_path = CUTF16String((const PA_Unichar *)&buf[0], len);
				if(eventFlags[i] & kFSEventStreamEventFlagItemIsDir)
					event_path += (const PA_Unichar *)":\0\0\0";
				
                std::lock_guard<std::mutex> lock(globalMutex);
				
				FW2::CALLBACK_EVENT_PATHS.push_back(event_path);
				FW2::CALLBACK_EVENT_FLAGS.push_back(eventFlags[i]);
				FW2::CALLBACK_EVENT_IDS.push_back([[NSDate date]timeIntervalSince1970]);
			}
			[path release];
			[u release];
		}
	}
	
	if([paths count])
		listenerLoopExecute();
}

#endif

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{

}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		listenerLoopFinish();
	}
}

#pragma mark -

#if VERSIONWIN
typedef struct
{
	HANDLE h;
	PA_Unichar a[40];//UUID
	PA_Unichar b[40];//UUID	
}Params;

unsigned __stdcall doIt(void *p)
{
	Params *params = (Params *)p;

	HANDLE h = params->h;
	
	HANDLE b = CreateEvent(NULL,
												 TRUE,
												 FALSE,
												 (const wchar_t *)params->b);
	
	if (b)
	{
		DWORD notifyFilter =
			FILE_NOTIFY_CHANGE_FILE_NAME
			| FILE_NOTIFY_CHANGE_DIR_NAME
			| FILE_NOTIFY_CHANGE_SIZE
			/* | FILE_NOTIFY_CHANGE_SECURITY */
			| FILE_NOTIFY_CHANGE_CREATION
			/* | FILE_NOTIFY_CHANGE_ATTRIBUTES */
			| FILE_NOTIFY_CHANGE_LAST_WRITE
			| FILE_NOTIFY_CHANGE_LAST_ACCESS;

		std::vector<wchar_t>buf(BUF_SIZE);
		DWORD bytesReturned;

		BOOL exit = FALSE;

		do {
			if (ReadDirectoryChangesW(h,
				(FILE_NOTIFY_INFORMATION *)&buf[0],
				BUF_SIZE,
				TRUE,
				notifyFilter,
				&bytesReturned,
				NULL,
				NULL))
			{
				if (bytesReturned)
				{
					DWORD data_len = bytesReturned;
					DWORD len = sizeof(data_len) + data_len;

					HANDLE fmOut = CreateFileMapping(
						INVALID_HANDLE_VALUE,
						NULL,
						PAGE_READWRITE,
						0, len,
						L"PARAM_OUT");
					if (fmOut)
					{
						LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_WRITE, 0, 0, len);
						if (bufOut)
						{
							unsigned char *p = (unsigned char *)bufOut;
							try
							{
								CopyMemory(p, &data_len, sizeof(data_len));
								p += sizeof(data_len);
								if (data_len)
								{
									CopyMemory(p, (void *)&buf[0], data_len);
								}
							}
							catch (...)
							{

							}
							UnmapViewOfFile(bufOut);
						}//bufOut

						HANDLE a = OpenEvent(EVENT_ALL_ACCESS, FALSE, (const wchar_t *)params->a);

						if (a)
						{
							SetEvent(a);
							CloseHandle(a);
						}

						WaitForSingleObject(b, INFINITE);
						ResetEvent(b);

						CloseHandle(fmOut);
					}

				}
			}
			
			if (FW2::PROCESS_SHOULD_TERMINATE || bytesReturned == 0) exit = TRUE;
			
		} while (!exit);

		CloseHandle(b);
	}
	_endthreadex(0);
	return 0;
}

#endif

void listenerLoop()
{
#if VERSIONWIN
	std::vector<HANDLE>::iterator it;
	std::vector<CUTF16String>watch_path_handle_paths;
	std::vector<HANDLE>watch_path_handles;

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        FW2::PROCESS_SHOULD_TERMINATE = false;
    }
    
	if (1)
	{
		for (int i = 0; i < FW2::WATCH_PATHS.getSize(); ++i)
		{
			CUTF16String path;
			FW2::WATCH_PATHS.copyUTF16StringAtIndex(&path, i);
			HANDLE h = CreateFileW(
														 (LPCWSTR)path.c_str(),
														 FILE_LIST_DIRECTORY,
														 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
														 NULL,
														 OPEN_EXISTING,
														 FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
														 NULL);
			if (h != INVALID_HANDLE_VALUE)
			{
				watch_path_handles.push_back(h);
				watch_path_handle_paths.push_back(path);
			}
		}
	}

	std::vector<HANDLE>handles;
	std::vector<HANDLE>signals;
	std::vector<CUTF16String>antisignalnames;
	std::vector<CUTF16String>folderpaths;
	std::vector<Params>params(watch_path_handles.size());

	static const __int64 SECS_BETWEEN_1601_AND_1970_EPOCHS = 116444736000000000LL;

	if(watch_path_handles.size() <= MAXIMUM_WAIT_OBJECTS)
	{
		size_t pos = 0;
		for(it = watch_path_handles.begin(); it != watch_path_handles.end(); ++it)
		{
			HANDLE h = *it;
			
			if(h != INVALID_HANDLE_VALUE)
			{
				Params *param = &params.at(pos);
				CUTF16String folderpath = watch_path_handle_paths.at(pos);
				param->h = h;
				C_TEXT _a;
				generateUuid(_a);
				C_TEXT _b;
				generateUuid(_b);
				unsigned char *p;
				DWORD data_len = _a.getUTF16Length() * sizeof(PA_Unichar);
				memset(param->a, 0x0, sizeof(param->a));
				memset(param->b, 0x0, sizeof(param->b));
				try
				{
					p = (unsigned char *)_a.getUTF16StringPtr();
					CopyMemory(param->a, p, data_len);
					p = (unsigned char *)_b.getUTF16StringPtr();
					CopyMemory(param->b, p, data_len);
				}
				catch (...)
				{

				}

				HANDLE a = CreateEvent(NULL,
					TRUE,
					FALSE,
					(const wchar_t *)param->a);
				
				if(a)
				{
					HANDLE h = (HANDLE)_beginthreadex(NULL /* security: handle not inherited */,
																						0 /* stack size:default */,
																						doIt,
																						param /* arguments */,
																						0 /* init flags:execute immediately */,
																						NULL /* thread id */);
					if(h)
					{
						signals.push_back(a);
						handles.push_back(h);
						folderpaths.push_back(folderpath);
						CUTF16String antisignalname;
						_b.copyUTF16String(&antisignalname);
						antisignalnames.push_back(antisignalname);
					}
				}
			}
			pos++;
		}
		
		BOOL exit = FALSE;
		
        /* Current process returns 0 for PA_NewProcess */
        PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
        
		do {
			DWORD count = WaitForMultipleObjects(signals.size(), &signals[0], FALSE, 16);//1 tick = 0.0166666
			switch (count)
			{
				case WAIT_TIMEOUT:
					PA_YieldAbsolute();
					PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);//59 ticks
					break;
				case WAIT_FAILED:
					exit = TRUE;
					break;
				default:
					for(DWORD i = count-WAIT_OBJECT_0; i < signals.size();++i)
					{
						HANDLE h = signals[i];
						CUTF16String path = folderpaths[i];
						ResetEvent(h);
						
						DWORD data_len = 0;
						DWORD len = sizeof(data_len);
						BOOL success = FALSE;
						
						HANDLE fmOut = CreateFileMapping(
																						 INVALID_HANDLE_VALUE,
																						 NULL,
																						 PAGE_READWRITE,
																						 0, len,
																						 L"PARAM_OUT");
				
						if (fmOut)
						{
							LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_READ, 0, 0, len);
							if (bufOut)
							{
								unsigned char *p = (unsigned char *)bufOut;
								try
								{
									CopyMemory(&data_len, p, sizeof(data_len));
									success = TRUE;
								}
								catch (...)
								{
									
								}
								UnmapViewOfFile(bufOut);
							}
							CloseHandle(fmOut);
						}
						if ((success) && (data_len))
						{
							len = len + data_len;
							
							fmOut = CreateFileMapping(
																				INVALID_HANDLE_VALUE,
																				NULL,
																				PAGE_READWRITE,
																				0, len,
																				L"PARAM_OUT");
							if (fmOut)
							{
								LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_READ, 0, 0, len);
								if (bufOut)
								{
									unsigned char *p = (unsigned char *)bufOut;
									p = p + sizeof(data_len);
									try
									{
										std::vector<uint8_t>buf(data_len);
										CopyMemory(&buf[0], p, data_len);
										size_t pos = 0;
										FILE_NOTIFY_INFORMATION *fni = (FILE_NOTIFY_INFORMATION *)&buf[0];
										size_t nextEntryOffset = fni->NextEntryOffset;
										do
										{
											DWORD fileNameLength = fni->FileNameLength;/* bytes */
											std::vector<PA_Unichar>ubuf(fileNameLength + sizeof(PA_Unichar));
											unsigned char *up = (unsigned char *)fni->FileName;
											CopyMemory(&ubuf[0], up, fileNameLength);
											CUTF16String event_path = path + CUTF16String((const PA_Unichar *)&ubuf[0]);

											double t = 0;
											FILETIME ft;
											GetSystemTimeAsFileTime(&ft);
											ULARGE_INTEGER ul;
											ul.LowPart = ft.dwLowDateTime;
											ul.HighPart = ft.dwHighDateTime;
											double ts = ((ul.QuadPart - SECS_BETWEEN_1601_AND_1970_EPOCHS) / 10000);
											
											int event_flag = 0;
											
											switch (fni->Action)
											{
												case FILE_ACTION_ADDED:
													event_flag = 256;
													break;
												case FILE_ACTION_REMOVED:
													event_flag = 512;
													break;
												case FILE_ACTION_MODIFIED:
													event_flag = 4096;
													break;
												case FILE_ACTION_RENAMED_OLD_NAME:
													event_flag = 2048;
													break;
												case FILE_ACTION_RENAMED_NEW_NAME:
													event_flag = 2048;
													break;
												default:
													break;
											}
											if (event_flag)
											{
												if (!(event_flag & FILE_ACTION_REMOVED))
												{
													if (PathIsDirectory((LPCTSTR)event_path.c_str()))
													{
														if (event_path.at(event_path.size() - 1) != L'\\')
															event_path += L'\\';
														event_flag |= 131072;
													}
													else
													{
														event_flag |= 65536;
													}
												}

												if (1)
												{
//                                                    std::lock_guard<std::mutex> lock(globalMutex);
													
													FW2::CALLBACK_EVENT_IDS.push_back(ts);
													FW2::CALLBACK_EVENT_PATHS.push_back(event_path);
													FW2::CALLBACK_EVENT_FLAGS.push_back(event_flag);
												}
												
												listenerLoopExecuteMethod();

											}
											nextEntryOffset = fni->NextEntryOffset;
											pos += nextEntryOffset;
											
											fni = (FILE_NOTIFY_INFORMATION *)&buf.at(pos);

										} while (nextEntryOffset);

									}
									catch (...)
									{
										
									}
									UnmapViewOfFile(bufOut);
								}
								CloseHandle(fmOut);
							}
							
						}
						
						CUTF16String antisignalname = antisignalnames.at(i);

						HANDLE antisignal = OpenEvent(EVENT_ALL_ACCESS, FALSE, (LPCWSTR)antisignalname.c_str());
						if(antisignal)
						{
							SetEvent(antisignal);
							CloseHandle(antisignal);
						}
					}
					break;
			}
			
			if (FW2::PROCESS_SHOULD_TERMINATE) exit = TRUE;
			
		} while (!exit);
		
		/* release signal handles */
		for(it = signals.begin(); it != signals.end(); ++it)
		{
			HANDLE h = *it;
			if(h != INVALID_HANDLE_VALUE)
			{
				CloseHandle(h);
			}
		}
	
		/* release thread handles */
		for (it = handles.begin(); it != handles.end(); ++it)
		{
			HANDLE h = *it;
			if (h != INVALID_HANDLE_VALUE)
			{
				CloseHandle(h);
			}
		}
	}
	
	/* release path handles */
	for(it = watch_path_handles.begin(); it != watch_path_handles.end(); ++it)
	{
		HANDLE h = *it;
		if(h != INVALID_HANDLE_VALUE)
		{
			CloseHandle(h);/* this will end the thread via bytesReturned == 0 */
		}
	}
#endif

#if VERSIONMAC
    
    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
	while(!PA_IsProcessDying())
	{
		PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = FW2::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = FW2::PROCESS_SHOULD_TERMINATE;
        }
		
		if(PROCESS_SHOULD_RESUME)
		{
            size_t EVENT_IDS;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                EVENT_IDS = FW2::CALLBACK_EVENT_IDS.size();
            }
            
			while (EVENT_IDS)
			{
				PA_YieldAbsolute();
				
				if(CALLBACK_IN_NEW_PROCESS)
				{
					C_TEXT processName;
					generateUuid(processName);
					PA_NewProcess((void *)listenerLoopExecuteMethod,
												FW2::MONITOR_PROCESS_STACK_SIZE,
												(PA_Unichar *)processName.getUTF16StringPtr());
				}else
				{
					listenerLoopExecuteMethod();
				}
				
				if (PROCESS_SHOULD_TERMINATE)
					break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    EVENT_IDS = FW2::CALLBACK_EVENT_IDS.size();
                    PROCESS_SHOULD_TERMINATE = FW2::PROCESS_SHOULD_TERMINATE;
                }
			}
			
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                FW2::PROCESS_SHOULD_RESUME = false;
            }
			
		}else
		{
            /* DELAY PROCESS does not work for PA_NewProcess */
			PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
		}
		
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = FW2::PROCESS_SHOULD_TERMINATE;
        }
        
		if(PROCESS_SHOULD_TERMINATE)
			break;
	}
	
	PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_end, NULL);
	
#endif
	
	if(1)
	{
        std::lock_guard<std::mutex> lock(globalMutex);
		
		FW2::WATCH_PATHS.setSize(0);
#if VERSIONMAC
		FW2::WATCH_PATHS_POSIX.setSize(0);
#endif
		FW2::CALLBACK_EVENT_PATHS.clear();
		FW2::CALLBACK_EVENT_FLAGS.clear();
		FW2::CALLBACK_EVENT_IDS.clear();
	}
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        FW2::METHOD_PROCESS_ID = 0;
    }
    
	PA_KillProcess();
}

void listenerLoopStart()
{
	if (!FW2::METHOD_PROCESS_ID)
	{
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        FW2::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                               FW2::MONITOR_PROCESS_STACK_SIZE,
                                               FW2::MONITOR_PROCESS_NAME);
	}
#if VERSIONWIN
	else
	{
		listenerLoopFinish();
	}
#endif
}

void listenerLoopFinish()
{
	if(FW2::METHOD_PROCESS_ID)
	{
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            FW2::PROCESS_SHOULD_TERMINATE = true;
        }

		PA_YieldAbsolute();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
            
            FW2::PROCESS_SHOULD_RESUME = true;
        }
	}
}

void listenerLoopExecute()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        FW2::PROCESS_SHOULD_TERMINATE = false;
    }

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        FW2::PROCESS_SHOULD_RESUME = true;
    }
}

void listenerLoopExecuteMethod()
{
    double ts;
    CUTF16String event_path;
    int event_flag;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);

        std::vector<CUTF16String>::iterator p = FW2::CALLBACK_EVENT_PATHS.begin();
#if VERSIONMAC
        std::vector<NSTimeInterval>::iterator e = FW2::CALLBACK_EVENT_IDS.begin();
#else
        std::vector<double>::iterator e = FW2::CALLBACK_EVENT_IDS.begin();
#endif
        
        std::vector<int>::iterator f = FW2::CALLBACK_EVENT_FLAGS.begin();
        
        ts = *e;
        event_path = *p;
        event_flag = *f;
        
        FW2::CALLBACK_EVENT_IDS.erase(e);
        FW2::CALLBACK_EVENT_PATHS.erase(p);
        FW2::CALLBACK_EVENT_FLAGS.erase(f);
    }

	method_id_t methodId = PA_GetMethodID((PA_Unichar *)FW2::WATCH_METHOD.getUTF16StringPtr());

	if(methodId)
	{
		PA_Variable	params[3];
		params[0] = PA_CreateVariable(eVK_Unistring);
		params[1] = PA_CreateVariable(eVK_Real);
		params[2] = PA_CreateVariable(eVK_Longint);
		PA_Unistring path = PA_CreateUnistring((PA_Unichar *)event_path.c_str());

		PA_SetStringVariable(&params[0], &path);
		PA_SetRealVariable(&params[1], ts);
		PA_SetLongintVariable(&params[2], event_flag);
		
		PA_ExecuteMethodByID(methodId, params, 3);
		
		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
		PA_ClearVariable(&params[2]);
	}else
	{
		PA_Variable	params[4];
		params[1] = PA_CreateVariable(eVK_Unistring);
		params[2] = PA_CreateVariable(eVK_Real);
		params[3] = PA_CreateVariable(eVK_Longint);
		PA_Unistring path = PA_CreateUnistring((PA_Unichar *)event_path.c_str());
		
		PA_SetStringVariable(&params[1], &path);
		PA_SetRealVariable(&params[2], ts);
		PA_SetLongintVariable(&params[3], event_flag);
		
		params[0] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring method = PA_CreateUnistring((PA_Unichar *)FW2::WATCH_METHOD.getUTF16StringPtr());
		PA_SetStringVariable(&params[0], &method);

        /* execute method */
		PA_ExecuteCommandByID(1007, params, 4);
		
		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
		PA_ClearVariable(&params[2]);
		PA_ClearVariable(&params[3]);
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
    
        case kInitPlugin :
        case kServerInitPlugin :            
            OnStartup();
            break;    

        case kCloseProcess :            
            OnCloseProcess();
            break;  
                
// --- Settings

		case 1 :
			FW_Set_watch_path(pResult, pParams);
			break;

		case 2 :
			FW_GET_WATCH_PATHS(pResult, pParams);
			break;

		case 3 :
			FW_Set_watch_method(pResult, pParams);
			break;

		case 4 :
			FW_Get_watch_method(pResult, pParams);
			break;

		case 5 :
			FW_Set_watch_paths(pResult, pParams);
			break;

	}
}

// ----------------------------------- Settings -----------------------------------

#pragma mark -

void FW_Set_watch_path(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_LONGINT Param2;
		C_LONGINT returnValue;
	
	if(!IsProcessOnExit())
	{
		Param1.fromParamAtIndex(pParams, 1);
		Param2.fromParamAtIndex(pParams, 2);
		
		if(!Param1.getUTF16Length())
		{
			//empty string passed
			returnValue.setIntValue(1);
			
			if(FW2::METHOD_PROCESS_ID)
			{
				listenerLoopFinish();
			}
			
		}else
		{
#if VERSIONMAC
			BOOL isDirectory = false;
			NSString *path = Param1.copyPath();
			NSString *pathHFS = Param1.copyUTF16String();
			if([[NSFileManager defaultManager]fileExistsAtPath:path isDirectory:&isDirectory])
			{
				if(isDirectory)
				{
					returnValue.setIntValue(1);
				}else
				{
					returnValue.setIntValue(MONITOR_FOLDER_NOT_FOLDER_ERROR);
				}
			}else
			{
				returnValue.setIntValue(MONITOR_FOLDER_INVALID_PATH_ERROR);
			}
#else
			CUTF16String path;
			Param1.copyUTF16String(&path);
			if(PathFileExists((LPCTSTR)path.c_str()))
			{
				if(PathIsDirectory((LPCTSTR)path.c_str()))
				{
					if(path.at(path.size() - 1) != L'\\')
						path += L'\\';
					
					returnValue.setIntValue(1);
				}else
				{
					returnValue.setIntValue(MONITOR_FOLDER_NOT_FOLDER_ERROR);
				}
			}else
			{
				returnValue.setIntValue(MONITOR_FOLDER_INVALID_PATH_ERROR);
			}
#endif
			if(returnValue.getIntValue() == 1)
			{
				
				if(1)
				{
                        std::lock_guard<std::mutex> lock(globalMutex);
					
						FW2::MONITOR_LATENCY = Param2.getIntValue();
						if(FW2::MONITOR_LATENCY < 1){
							FW2::MONITOR_LATENCY = 1.0;
						}
						if(FW2::MONITOR_LATENCY > 60){
							FW2::MONITOR_LATENCY = 60.0;
						}
					
					FW2::WATCH_PATHS.setSize(0);
#if VERSIONMAC
					FW2::WATCH_PATHS.appendUTF16String(@"");
					FW2::WATCH_PATHS.appendUTF16String(pathHFS);
					FW2::WATCH_PATHS_POSIX.setSize(0);
					FW2::WATCH_PATHS_POSIX.appendUTF16String(@"");
					FW2::WATCH_PATHS_POSIX.appendUTF16String(path);
#else
					FW2::WATCH_PATHS.appendUTF16String((const PA_Unichar *)"\0\0", 0);
					FW2::WATCH_PATHS.appendUTF16String(&path);
#endif
				}
				
#if VERSIONMAC
				PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_start, NULL);
#endif
				listenerLoopStart();
			}
			
#if VERSIONMAC
			[path release];
			[pathHFS release];
#endif
		}
		
	}
	
	returnValue.setReturn(pResult);
}

void FW_Set_watch_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        if(!Param1.getUTF16Length())
        {
            FW2::WATCH_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
        }else{
            FW2::WATCH_METHOD.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());
        }
    }

	returnValue.setIntValue(1);
	returnValue.setReturn(pResult);
}

void FW_Set_watch_paths(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	if(!IsProcessOnExit())
	{
		Param1.fromParamAtIndex(pParams, 1);
		Param2.fromParamAtIndex(pParams, 2);
		
		bool isEmpty = !Param1.getSize();
		
		if(Param1.getSize() == 1)
		{
			CUTF16String e1;
			Param1.copyUTF16StringAtIndex(&e1, 1);
			isEmpty = isEmpty || !e1.length();
		}
		
		if(isEmpty)
		{
			//empty array passed
			returnValue.setIntValue(1);
			if(FW2::METHOD_PROCESS_ID)
			{
				listenerLoopFinish();
			}
			
		}else{
			
			uint32_t i, length = Param1.getSize();
	
			if(1)
			{
                std::lock_guard<std::mutex> lock(globalMutex);
				
				FW2::WATCH_PATHS.setSize(0);
#if VERSIONMAC
				FW2::WATCH_PATHS.appendUTF16String(@"");
				FW2::WATCH_PATHS_POSIX.setSize(0);
				FW2::WATCH_PATHS_POSIX.appendUTF16String(@"");
#else
				FW2::WATCH_PATHS.appendUTF16String((const PA_Unichar *)"\0\0", 0);
#endif
			}
			
			if(1)
			{
                std::lock_guard<std::mutex> lock(globalMutex);
				
				for(i = 0; i < length; ++i)
				{
#if VERSIONMAC
					BOOL isDirectory = false;
					NSString *path = Param1.copyPathAtIndex(i);
					NSString *pathHFS = Param1.copyUTF16StringAtIndex(i);
					if([[NSFileManager defaultManager]fileExistsAtPath:path isDirectory:&isDirectory]){
						
						if(isDirectory)
						{
							FW2::WATCH_PATHS.appendUTF16String(pathHFS);
							FW2::WATCH_PATHS_POSIX.appendUTF16String(path);
						}else
						{
							returnValue.setIntValue(MONITOR_FOLDER_NOT_FOLDER_ERROR);
						}
					}else
					{
						returnValue.setIntValue(MONITOR_FOLDER_INVALID_PATH_ERROR);
					}
					[pathHFS release];
					[path release];
#else
					CUTF16String path;
					Param1.copyUTF16StringAtIndex(&path, i);
					if(PathFileExists((LPCTSTR)path.c_str()))
					{
						if(PathIsDirectory((LPCTSTR)path.c_str()))
						{
							if(path.at(path.size() - 1) != L'\\')
								path += L'\\';
							
							FW2::WATCH_PATHS.appendUTF16String(&path);
						}else
						{
							returnValue.setIntValue(MONITOR_FOLDER_NOT_FOLDER_ERROR);
						}
					}else
					{
						returnValue.setIntValue(MONITOR_FOLDER_INVALID_PATH_ERROR);
					}
#endif
				}
			}
			
			if(FW2::WATCH_PATHS.getSize() > 1)
			{
				if(1)
				{
                    std::lock_guard<std::mutex> lock(globalMutex);
					
					returnValue.setIntValue(1);
					
					FW2::MONITOR_LATENCY = Param2.getIntValue();
					if(FW2::MONITOR_LATENCY < 1)
					{
						FW2::MONITOR_LATENCY = 1.0;
					}
					if(FW2::MONITOR_LATENCY > 60)
					{
						FW2::MONITOR_LATENCY = 60.0;
					}
				}
				
#if VERSIONMAC
				PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_start, NULL);
#endif
			listenerLoopStart();
			}

		}
		
	}
	
	returnValue.setReturn(pResult);
}

void FW_GET_WATCH_PATHS(sLONG_PTR *pResult, PackagePtr pParams)
{
	FW2::WATCH_PATHS.toParamAtIndex(pParams, 1);
}

void FW_Get_watch_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	FW2::WATCH_METHOD.setReturn(pResult);
}
